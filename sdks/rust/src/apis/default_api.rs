/*
 * Kandji API
 *
 * <html><head></head><body><h1 id=\"welcome-to-the-kandji-api-documentation\">Welcome to the Kandji API Documentation</h1>\\n<p>You can find your API URL in Settings &gt; Access. The API URL will follow the below formats.</p>\\n<ul>\\n<li><p>US - <code>https://SubDomain.api.kandji.io</code></p>\\n</li>\\n<li><p>EU - <code>https://SubDomain.api.eu.kandji.io</code></p>\\n</li>\\n</ul>\\n<p>For information on how to obtain an API token, please refer to the following support article.</p>\\n<p><a href=\"https://support.kandji.io/api\">https://support.kandji.io/api</a></p>\\n<h4 id=\"rate-limit\">Rate Limit</h4>\\n<p>The Kandji API currently has an API rate limit of 10,000 requests per hour per customer.</p>\\n<h4 id=\"request-methods\">Request Methods</h4>\\n<p>HTTP request methods supported by the Kandji API.</p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th>Method</th>\\n<th>Definition</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>GET</td>\\n<td>The <code>GET</code> method requests a representation of the specified resource.</td>\\n</tr>\\n<tr>\\n<td>POST</td>\\n<td>The <code>POST</code> method submits an entity to the specified resource.</td>\\n</tr>\\n<tr>\\n<td>PATCH</td>\\n<td>The <code>PATCH</code> method applies partial modifications to a resource.</td>\\n</tr>\\n<tr>\\n<td>DELETE</td>\\n<td>The <code>DELETE</code> method deletes the specified resource.</td>\\n</tr>\\n</tbody>\\n</table>\\n</div><h4 id=\"response-codes\">Response codes</h4>\\n<p>Not all response codes apply to every endpoint.</p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th>Code</th>\\n<th>Response</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>200</td>\\n<td>OK</td>\\n</tr>\\n<tr>\\n<td>201</td>\\n<td>Created</td>\\n</tr>\\n<tr>\\n<td>204</td>\\n<td>No content</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>Typical response when sending the DELETE method.</td>\\n</tr>\\n<tr>\\n<td>400</td>\\n<td>Bad Request</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Command already running\" - The command may already be running in a <em>Pending</em> state waiting on the device.</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Command is not allowed for current device\" - The command may not be compatible with the target device.</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"JSON parse error - Expecting ',' delimiter: line 3 column 2 (char 65)\"</td>\\n</tr>\\n<tr>\\n<td>401</td>\\n<td>Unauthorized</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>This error can occur if the token is incorrect, was revoked, or the token has expired.</td>\\n</tr>\\n<tr>\\n<td>403</td>\\n<td>Forbidden</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>The request was understood but cannot be authorized.</td>\\n</tr>\\n<tr>\\n<td>404</td>\\n<td>Not found</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>Unable to locate the resource in the Kandji tenant.</td>\\n</tr>\\n<tr>\\n<td>415</td>\\n<td>Unsupported Media Type</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>The request contains a media type which the server or resource does not support.</td>\\n</tr>\\n<tr>\\n<td>500</td>\\n<td>Internal server error</td>\\n</tr>\\n<tr>\\n<td>503</td>\\n<td>Service unavailable</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>This error can occur if a file upload is still being processed via the custom apps API.</td>\\n</tr>\\n</tbody>\\n</table>\\n</div><h4 id=\"data-structure\">Data structure</h4>\\n<p>The API returns all structured responses in JSON schema format.</p>\\n<h4 id=\"examples\">Examples</h4>\\n<p>Code examples using the API can be found in the Kandji support <a href=\"https://github.com/kandji-inc/support/tree/main/api-tools\">GitHub</a>.</p>\\n</body></html>
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_assign_library_item_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdAssignLibraryItemPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_list_library_items_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdListLibraryItemsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_ota_enrollment_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdOtaEnrollmentProfileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_blueprint_id_remove_library_item_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsBlueprintIdRemoveLibraryItemPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_blueprints_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1BlueprintsTemplatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_blankpush_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionBlankpushPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_clearpasscode_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionClearpasscodePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_deleteuser_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionDeleteuserPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_disablelostmode_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionDisablelostmodePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_enablelostmode_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionEnablelostmodePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_erase_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionErasePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_lock_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionLockPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_playlostmodesound_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionPlaylostmodesoundPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_reinstallagent_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionReinstallagentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_remotedesktop_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionRemotedesktopPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_renewmdmprofile_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionRenewmdmprofilePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_restart_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionRestartPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_setname_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionSetnamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_shutdown_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionShutdownPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_unlockaccount_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionUnlockaccountPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_updateinventory_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionUpdateinventoryPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_action_updatelocation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActionUpdatelocationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_activitylimit300_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdActivitylimit300GetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_apps_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdAppsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_commandslimit300_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdCommandslimit300GetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_details_lostmode_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdDetailsLostmodeDeleteError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_details_lostmode_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdDetailsLostmodeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_library_items_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdLibraryItemsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_notes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdNotesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_notes_note_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdNotesNoteIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_notes_note_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdNotesNoteIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_notes_note_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdNotesNoteIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_notes_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdNotesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_parameters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdParametersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_secrets_bypasscode_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdSecretsBypasscodeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_secrets_filevaultkey_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdSecretsFilevaultkeyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_secrets_recoverypassword_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdSecretsRecoverypasswordGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_secrets_unlockpin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdSecretsUnlockpinGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_devices_device_id_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1DevicesDeviceIdStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_deviceslimit300_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1Deviceslimit300GetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_ade_token_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeAdeTokenIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_ade_token_id_devices_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeAdeTokenIdDevicesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_ade_token_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeAdeTokenIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_ade_token_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeAdeTokenIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_ade_token_id_renew_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeAdeTokenIdRenewPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_devices_device_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeDevicesDeviceIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_devices_device_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeDevicesDeviceIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_devices_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeDevicesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_integrations_apple_ade_public_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IntegrationsAppleAdePublicKeyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_apps_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomAppsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_apps_library_item_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomAppsLibraryItemIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_apps_library_item_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomAppsLibraryItemIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_apps_library_item_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomAppsLibraryItemIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_apps_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomAppsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_apps_upload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomAppsUploadPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomProfilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_profiles_library_item_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomProfilesLibraryItemIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_profiles_library_item_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomProfilesLibraryItemIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_profiles_library_item_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomProfilesLibraryItemIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_profiles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomProfilesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_scripts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomScriptsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_scripts_library_item_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomScriptsLibraryItemIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_scripts_library_item_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomScriptsLibraryItemIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_scripts_library_item_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomScriptsLibraryItemIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_custom_scripts_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryCustomScriptsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_library_items_library_item_id_activity_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryLibraryItemsLibraryItemIdActivityGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_library_library_items_library_item_id_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LibraryLibraryItemsLibraryItemIdStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_activation_lock_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismActivationLockGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_application_firewall_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismApplicationFirewallGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_apps_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismAppsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_certificates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismCertificatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_countcategoryapps_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismCountcategoryappsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_desktop_and_screensaver_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismDesktopAndScreensaverGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_device_information_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismDeviceInformationGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_export_export_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismExportExportIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_export_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismExportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_filevault_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismFilevaultGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_gatekeeper_and_xprotect_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismGatekeeperAndXprotectGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_installed_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismInstalledProfilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_kernel_extensions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismKernelExtensionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_launch_agents_and_daemons_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismLaunchAgentsAndDaemonsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_local_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismLocalUsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_startup_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismStartupSettingsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_system_extensions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismSystemExtensionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_prism_transparency_database_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1PrismTransparencyDatabaseGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_self_service_categories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SelfServiceCategoriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_settings_licensing_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1SettingsLicensingGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_tags_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1TagsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_tags_tag_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1TagsTagIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_tags_tag_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1TagsTagIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_tagssearchaccuhive_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1TagssearchaccuhiveGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_threat_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ThreatDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_user_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersUserIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUrlPostError {
    UnknownValue(serde_json::Value),
}


/// <p>This endpoint allows assigning a library item to a specific blueprint (classic and maps). The response will include a list of library item IDs assigned to the blueprint.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n<h3 id=\"request-body\">Request Body</h3>\\n<ul>\\n<li><p><code>library_item_id</code> (string, required)</p>\\n</li>\\n<li><p><code>assignment_node_id</code> (string, required for maps)</p>\\n<ul>\\n<li>Note: To find the assignment_node_id, view the map in a browser. Then, on your keyboard, press and hold the Option ⌥ key. Each node ID remains fixed for the lifespan of the node on the map.</li>\\n</ul>\\n</li>\\n</ul>\\n<h3 id=\"error-responses\">Error responses</h3>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th><strong>Code</strong></th>\\n<th><strong>Body</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>400 - Bad Request</td>\\n<td>Bad Request</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Library Item already exists on Blueprint\"</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Library Item already exists in Assignment Node\"</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"assignment_node_id cannot be provided for Classic Blueprint\"</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Must provide assignment_node_id for Assignment Map Blueprint\"</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_blueprints_blueprint_id_assign_library_item_post(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdAssignLibraryItemPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}/assign-library-item", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdAssignLibraryItemPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <h1 id=\"warning\"><strong>WARNING!</strong></h1>\\n<p>This is a HIGHLY destructive action.</p>\\n<p>Deleting a Blueprint will un-manage ALL devices assigned to the Blueprint.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n
pub async fn api_v1_blueprints_blueprint_id_delete(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns information about a specific blueprint based on blueprint ID.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n
pub async fn api_v1_blueprints_blueprint_id_get(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This API endpoint retrieves a list of library items associated with a specific blueprint. (classic and maps). Requires that the blueprint ID is passed as a path parameter in the URL.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n<h3 id=\"response-fields\">Response fields</h3>\\n<ul>\\n<li><p><code>count</code> (int): The total count of library items.</p>\\n</li>\\n<li><p><code>next</code> (str): The URL for the next page of results, if available. If not available will value will be <code>null</code>.</p>\\n</li>\\n<li><p><code>previous</code> (str): The URL for the previous page of results, if available. If not available will value will be <code>null</code>.</p>\\n</li>\\n<li><p><code>results</code> (object): An array containing objects with the following fields:</p>\\n<ul>\\n<li><p><code>id</code> (str): The ID of the library item.</p>\\n</li>\\n<li><p><code>name</code> (str): The name of the library item.</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n
pub async fn api_v1_blueprints_blueprint_id_list_library_items_get(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdListLibraryItemsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}/list-library-items", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdListLibraryItemsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the manual enrollment profile (.mobileconfig file) for a specified Blueprint.</p>\\n<p>This request will return the enrollment profile even if \"Require Authentication\" is configured for the Blueprint in Manual Enrollment.</p>\\n<p>The enrollment profile will be returned in raw form with response headers:</p>\\n<ul>\\n<li><p><code>Content-Type</code> = <code>application/x-apple-aspen-config</code></p>\\n</li>\\n<li><p><code>Content-Disposition</code> = <code>attachment;filename=kandji-enroll.mobileconfig</code></p>\\n</li>\\n</ul>\\n<p>An optional query parameter <code>sso=true</code> can be used to return a URL for SSO authentication instead. If this query parameter is used for a Blueprint that does not require authentication, then the enrollment profile will be returned.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n
pub async fn api_v1_blueprints_blueprint_id_ota_enrollment_profile_get(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdOtaEnrollmentProfileGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}/ota-enrollment-profile", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdOtaEnrollmentProfileGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This requests allows updating of the name, icon, icon color, description, enrollment code, and active status on an existing blueprint.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n
pub async fn api_v1_blueprints_blueprint_id_patch(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint allows removing a library item from a specific blueprint (classic and maps). The response will include a list of library item IDs assigned to the blueprint.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>blueprint_id</code> (path parameter): The unique identifier of the blueprint.</p>\\n<h3 id=\"request-body\">Request Body</h3>\\n<ul>\\n<li><p><code>library_item_id</code> (string, required)</p>\\n</li>\\n<li><p><code>assignment_node_id</code> (string, required for maps)</p>\\n</li>\\n</ul>\\n<h3 id=\"error-responses\">Error responses</h3>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th><strong>Code</strong></th>\\n<th><strong>Body</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>400 - Bad Request</td>\\n<td>Bad Request</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"assignment_node_id cannot be provided for Classic Blueprint\"</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Must provide assignment_node_id for Assignment Map Blueprint\"</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Library Item does not exist on Blueprint\"</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td>\"Library Item does not exist in Assignment Node\"</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_blueprints_blueprint_id_remove_library_item_post(configuration: &configuration::Configuration, blueprint_id: &str) -> Result<serde_json::Value, Error<ApiV1BlueprintsBlueprintIdRemoveLibraryItemPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/{blueprint_id}/remove-library-item", local_var_configuration.base_path, blueprint_id=crate::apis::urlencode(blueprint_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsBlueprintIdRemoveLibraryItemPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns a list of a blueprint records in the Kandji tenant. Optional query parameters can be specified to filter the results.</p>\\n
pub async fn api_v1_blueprints_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1BlueprintsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request creates a new empty Blueprint or a new Blueprint from a template. The keys <code>name</code> and <code>enrollment_code</code> <code>is_active</code> are required, and the blueprint name key must be unique from the existing blueprint names in the Kandji tenant.</p>\\n<p>optionally, <code>type: map</code> can be used when creating a new Assignment Map blueprint.</p>\\n<p>Note: If cloning an existing blueprint,`type` value and the type of sourced (`source.id`) blueprint must match and `source.type` value must be set to `blueprint`.</p>\\n
pub async fn api_v1_blueprints_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1BlueprintsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// 
pub async fn api_v1_blueprints_templates_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1BlueprintsTemplatesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/blueprints/templates/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1BlueprintsTemplatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to initiate a blank push.</p>\\n<p><a href=\"https://support.kandji.io/what-is-a-blank-push\">Using the Blank Push command</a></p>\\n
pub async fn api_v1_devices_device_id_action_blankpush_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionBlankpushPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/blankpush", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionBlankpushPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to clear a device passcode. Available for iPhone and iPad.</p>\\n
pub async fn api_v1_devices_device_id_action_clearpasscode_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionClearpasscodePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/clearpasscode", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionClearpasscodePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to delete a local user account on macOS and Shared iPad (Device Supervision via Automated Device Enrollment is required).</p>\\n<p><strong>Request Body Parameters</strong>: application/json</p>\\n<hr />\\n<p><code>DeleteAllUsers</code> - <code>boolean</code></p>\\n<p><code>ForceDeletion</code> - <code>boolean</code></p>\\n<p><code>UserName</code> - <code>string</code></p>\\n
pub async fn api_v1_devices_device_id_action_deleteuser_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionDeleteuserPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/deleteuser", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionDeleteuserPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This command will send a request to turn off lost mode on iOS and iPadOS.</p>\\n<p>If the command is already pending, the message \"<em>Disable lost mode is already pending for this device.</em>\" will be in the response.</p>\\n
pub async fn api_v1_devices_device_id_action_disablelostmode_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionDisablelostmodePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/disablelostmode", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionDisablelostmodePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to remotely turn on lost mode on iOS and iPadOS.</p>\\n<p>Optionally, a JSON payload can be sent in the request to set a lock message, phone number, and footnote on the target device.</p>\\n
pub async fn api_v1_devices_device_id_action_enablelostmode_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionEnablelostmodePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/enablelostmode", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionEnablelostmodePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to erase the device.</p>\\n<p>iOS 4.0+, iPadOS 4.0+, macOS 10.7+, tvOS 10.2+</p>\\n<p><strong>Request Body Parameters: application/json</strong></p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th>Key</th>\\n<th>Type</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>PIN</code></td>\\n<td><code>string</code></td>\\n<td>The six-character PIN for Find My. This value is available in macOS 10.8 and later.</td>\\n</tr>\\n<tr>\\n<td><code>PreserveDataPlan</code></td>\\n<td><code>boolean</code></td>\\n<td>If true, preserve the data plan on an iPhone or iPad with eSIM functionality, if one exists. This value is available in iOS 11 and later.  <br />  <br />Default: true</td>\\n</tr>\\n<tr>\\n<td><code>DisallowProximitySetup</code></td>\\n<td><code>boolean</code></td>\\n<td>If true, disable Proximity Setup on the next reboot and skip the pane in Setup Assistant. This value is available in iOS 11 and later. Prior to iOS 14, don’t use this option with any other option.  <br />  <br />Default: false</td>\\n</tr>\\n<tr>\\n<td><code>ReturnToService</code></td>\\n<td><code>object</code></td>\\n<td>(iOS 17 and later and iPadOS 17 and later and with Shared iPad ) When sending the erase device command to mobile devices, use this key to enable Return to Service. Include an optional Wi-Fi payload ProfileId to allow the device to connect to a Wi-Fi network automatically after being erased. If a Wi-Fi ProfileId is not provided and the mobile device is not tethered to a Mac to share the network connection, the end-user will be required to select a Wi-Fi network to complete the setup.  <br />  <br />If sent to any macOS computer or to mobile devices on iOS 16 or iPadOS 16 and below, the RTS keys will be ignored, and only the erase device command will be issued to the device.</td>\\n</tr>\\n<tr>\\n<td>- <code>Enabled</code></td>\\n<td><code>boolean</code></td>\\n<td>(Required) If true, the device tries to re-enroll itself automatically after erasure. The user needs to deactivate all activation locks for this feature to work correctly.</td>\\n</tr>\\n<tr>\\n<td>- <code>ProfileId</code></td>\\n<td><code>string</code></td>\\n<td>Profile ID value associated with a Wi-Fi profile payload. This is required when the device doesn’t have ethernet access.</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_devices_device_id_action_erase_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionErasePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/erase", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionErasePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to remotely lock a device.</p>\\n<p>For macOS clients, an unlock PIN will be created, and returned in the response.</p>\\n<blockquote>\\n<p><strong>Caution !!!</strong><br /><em>For a Mac with Apple silicon running a version of macOS before 11.5 will deactivate the Mac. To reactivate, the Mac requires a network connection and authentication by a Secure Token enabled local administrator.</em></p>\\n</blockquote>\\n<p>Optionally, a JSON payload can be sent in the request to set a lock message and phone number on the target device.</p>\\n<p><strong>Note:</strong> For macOS, although the lock message is displayed on all types of Mac computers, the phone number is displayed only on a Mac with Apple silicon.</p>\\n<h4 id=\"response-properties\">Response properties</h4>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th>Property</th>\\n<th>Description</th>\\n<th>Type</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>PIN</td>\\n<td>Six digit pin code used to unlock a Mac.</td>\\n<td>String</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_devices_device_id_action_lock_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionLockPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/lock", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionLockPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This command will tell the target iOS or iPadOS device to play the lost mode sound.</p>\\n<p><strong>Note</strong>: The Lost Mode sound will play for 2 minutes, even if the device is in silent mode. Anyone finding the device can silence the sound by pressing any of its side buttons.</p>\\n
pub async fn api_v1_devices_device_id_action_playlostmodesound_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionPlaylostmodesoundPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/playlostmodesound", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionPlaylostmodesoundPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command reinstall the Kandji Agent. Available for macOS devices.</p>\\n
pub async fn api_v1_devices_device_id_action_reinstallagent_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionReinstallagentPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/reinstallagent", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionReinstallagentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to control the Remote Management status on a Mac. This MDM command turns on (or turns off) Remote Management with <em>Observe</em> and <em>Control</em> permissions given to all users*.*</p>\\n<p><strong>Request Body Parameters</strong>: application/json</p>\\n<hr />\\n<p><code>EnableRemoteDesktop</code> - <code>boolean</code></p>\\n
pub async fn api_v1_devices_device_id_action_remotedesktop_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionRemotedesktopPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/remotedesktop", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionRemotedesktopPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to re-install the existing root MDM profile for a given device ID. This command will not impact any existing configurations, apps, or profiles.</p>\\n
pub async fn api_v1_devices_device_id_action_renewmdmprofile_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionRenewmdmprofilePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/renewmdmprofile", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionRenewmdmprofilePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to remotely restart a device.</p>\\n<ul>\\n<li><p><code>RebuildKernelCache</code> - If <code>true</code>, the system rebuilds the kernel cache during a device restart. If <code>BootstrapTokenAllowedForAuthentication</code> is <code>true</code> inSecurityInfoResponse.SecurityInfo, the device requests the bootstrap token from MDM before executing this command. This value is available in macOS 11 and later. Default: false</p>\\n</li>\\n<li><p><code>NotifyUser</code> - If <code>true</code>, notifies the user to restart the device at their convenience. Forced restart if the device is at <code>loginwindow</code> with no logged-in users. The user can dismiss the notification and ignore the request. No further notifications display unless you resend the command. This value is available in macOS 11.3 and later. Default: false</p>\\n</li>\\n</ul>\\n
pub async fn api_v1_devices_device_id_action_restart_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionRestartPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/restart", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionRestartPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to set the device name.</p>\\n<p><strong>Request Body Parameters</strong>: application/json</p>\\n<hr />\\n<p><code>DeviceName</code> - <code>string</code></p>\\n
pub async fn api_v1_devices_device_id_action_setname_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionSetnamePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/setname", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionSetnamePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to shutdown a device.</p>\\n
pub async fn api_v1_devices_device_id_action_shutdown_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionShutdownPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/shutdown", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionShutdownPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to unlock a user account that locked by the system because of too many failed password attempts. Available for macOS.</p>\\n<p><strong>Request Body Parameters</strong>: application/json</p>\\n<hr />\\n<p><code>UserName</code> - <code>string</code></p>\\n
pub async fn api_v1_devices_device_id_action_unlockaccount_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionUnlockaccountPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/unlockaccount", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionUnlockaccountPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to start a check-in for a device, initiating the daily MDM commands and MDM logic.</p>\\n
pub async fn api_v1_devices_device_id_action_updateinventory_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionUpdateinventoryPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/updateinventory", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionUpdateinventoryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to update the location data on iOS and iPadOS.</p>\\n
pub async fn api_v1_devices_device_id_action_updatelocation_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActionUpdatelocationPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/action/updatelocation", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActionUpdatelocationPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the device activity for a specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_activitylimit300_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdActivitylimit300GetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/activity?limit=300", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdActivitylimit300GetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns a list of all installed apps for a specified Device ID.</p>\\n<p>For iPhone and iPad, the preinstalled Apple apps are not reported.</p>\\n
pub async fn api_v1_devices_device_id_apps_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdAppsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/apps", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdAppsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends a request to get information about the commands sent to a given device ID.</p>\\n<h3 id=\"mdm-status-codes\">MDM Status Codes</h3>\\n<ul>\\n<li>1 : Command is Pending</li>\\n<li>2 : Command is running</li>\\n<li>3 : Command completed</li>\\n<li>4 : Command failed</li>\\n<li>5 : Command received \"Not Now\" response</li>\\n</ul>\\n
pub async fn api_v1_devices_device_id_commandslimit300_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdCommandslimit300GetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/commands?limit=300", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdCommandslimit300GetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint sends an MDM command to delete a device. This will remove the device record from Kandji and send a Remove Management command. For macOS devices, it will also send an uninstall command to the Kandji Agent at the next agent checkin.</p>\\n
pub async fn api_v1_devices_device_id_delete(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the device details for a specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_details_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdDetailsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/details", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdDetailsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint can be used to send a cancelation request if Lost Mode is in an error state for a given iOS or iPadOS device.</p>\\n
pub async fn api_v1_devices_device_id_details_lostmode_delete(configuration: &configuration::Configuration, device_id: &str) -> Result<(), Error<ApiV1DevicesDeviceIdDetailsLostmodeDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/details/lostmode", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdDetailsLostmodeDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the device lost mode details for a specified Device ID.</p>\\n<p><strong>Note</strong>: Lost Mode is is only available for iOS and iPadOS. For more information, please see this <a href=\"https://support.kandji.io/a/solutions/articles/72000573873\">Kandji support artilcle</a>.</p>\\n
pub async fn api_v1_devices_device_id_details_lostmode_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdDetailsLostmodeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/details/lostmode", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdDetailsLostmodeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the high-level information for a specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request gets all library items and their statuses for a specified Device ID</p>\\n<h4 id=\"possible-library-item-status-values\">Possible library item status values</h4>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th><strong>Value</strong></th>\\n<th><strong>Type</strong></th>\\n<th><strong>Additional Info</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>AVAILABLE</td>\\n<td>string</td>\\n<td>Library item available in Self Service</td>\\n</tr>\\n<tr>\\n<td>CACHED</td>\\n<td>string</td>\\n<td>Library item downloaded for install but not yet installed</td>\\n</tr>\\n<tr>\\n<td>CHANGE_PENDING</td>\\n<td>string</td>\\n<td>Recovery Password library item has changes that have not yet been applied</td>\\n</tr>\\n<tr>\\n<td>DOWNLOADING</td>\\n<td>string</td>\\n<td>Library item downloading</td>\\n</tr>\\n<tr>\\n<td>ERROR</td>\\n<td>string</td>\\n<td>Audit failure</td>\\n</tr>\\n<tr>\\n<td>EXCLUDED</td>\\n<td>string</td>\\n<td>Not in scope for assignment rule</td>\\n</tr>\\n<tr>\\n<td>INCOMPATIBLE</td>\\n<td>string</td>\\n<td>Not compatible with device or OS version</td>\\n</tr>\\n<tr>\\n<td>INSTALLING</td>\\n<td>string</td>\\n<td>Library item installing</td>\\n</tr>\\n<tr>\\n<td>PASS</td>\\n<td>string</td>\\n<td>Device meets requirements</td>\\n</tr>\\n<tr>\\n<td>PENDING</td>\\n<td>string</td>\\n<td>Waiting on device, not yet installed (All library items except for config profiles)</td>\\n</tr>\\n<tr>\\n<td>failed</td>\\n<td>string</td>\\n<td>Configuration profile failed to install</td>\\n</tr>\\n<tr>\\n<td>pending</td>\\n<td>string</td>\\n<td>Waiting on device, Configuration profile not yet installed</td>\\n</tr>\\n<tr>\\n<td>success</td>\\n<td>string</td>\\n<td>Configuration profile installed</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_devices_device_id_library_items_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdLibraryItemsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/library-items", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdLibraryItemsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request gets all notes for the specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_notes_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdNotesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/notes", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdNotesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request deletes a specified note (Note ID) for the specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_notes_note_id_delete(configuration: &configuration::Configuration, device_id: &str, note_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdNotesNoteIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/notes/{note_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id), note_id=crate::apis::urlencode(note_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdNotesNoteIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request retrieves a specified note (Note ID) for the specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_notes_note_id_get(configuration: &configuration::Configuration, device_id: &str, note_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdNotesNoteIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/notes/{note_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id), note_id=crate::apis::urlencode(note_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdNotesNoteIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request patches a specified note (Note ID) for the specified Device ID.</p>\\n
pub async fn api_v1_devices_device_id_notes_note_id_patch(configuration: &configuration::Configuration, authorization: &str, content_type: &str, device_id: &str, note_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdNotesNoteIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/notes/{note_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id), note_id=crate::apis::urlencode(note_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    local_var_req_builder = local_var_req_builder.header("Content-Type", content_type.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdNotesNoteIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request creates a note for the specified device ID.</p>\\n
pub async fn api_v1_devices_device_id_notes_post(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdNotesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/notes", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdNotesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the parameters and their statuses for a specified Device ID</p>\\n<p>This endpoint is only applicable to macOS clients.</p>\\n<p>The parameters will be returned as a list of IDs. These IDs can be correlated with the parameter names available here: <a href=\"https://github.com/kandji-inc/support/wiki/Devices-API---Parameter-Correlations\">https://github.com/kandji-inc/support/wiki/Devices-API---Parameter-Correlations</a></p>\\n<p><strong>Possible parameter status values</strong></p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th><strong>Value</strong></th>\\n<th><strong>Type</strong></th>\\n<th><strong>Additional Info</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>ERROR</td>\\n<td>string</td>\\n<td>Audit failure</td>\\n</tr>\\n<tr>\\n<td>INCOMPATIBLE</td>\\n<td>string</td>\\n<td>Not compatible with device or OS version</td>\\n</tr>\\n<tr>\\n<td>PASS</td>\\n<td>string</td>\\n<td>Device meets requirements</td>\\n</tr>\\n<tr>\\n<td>PENDING</td>\\n<td>string</td>\\n<td>Waiting on device. Not yet run.</td>\\n</tr>\\n<tr>\\n<td>REMEDIATED</td>\\n<td>string</td>\\n<td>Parameter remediated</td>\\n</tr>\\n<tr>\\n<td>WARNING</td>\\n<td>string</td>\\n<td>Muted alert</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_devices_device_id_parameters_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdParametersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/parameters", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdParametersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to update device information, such as the assigned blueprint, user, Asset Tag, and Tags. It is not required to use all attributes in a given request. For example if you only want to update the assigned blueprint, you only need to pass the <code>blueprint_id</code> in the request payload.</p>\\n<p><strong>NOTE</strong>: With the introduction of a UUID value for user ID in the <a href=\"https://api-docs.kandji.io/#b107eb0a-b586-414f-bc4c-3d2b304cfd5f\">Users API</a>, the Device PATCH endpoint will support both the depricated user ID integer value and the new user ID UUID value when updating the user assignment for a device. The ability to update user assignment via the integer ID value will be removed starting January 2025.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>\\n<h3 id=\"additional-information\">Additional information</h3>\\n<p>User ID can be found using the <code>list users</code> API</p>\\n<p>A Blueprint ID can be found using the <code>list blueprints</code> API or in the URL path while on a Blueprint overview page.</p>\\n<p>For example, for this URL <a href=\"https://subdomain.kandji.io/blueprints/6391086e-85a1-4820-813c-f9c75025fff4\">https://subdomain.kandji.io/blueprints/6391086e-85a1-4820-813c-f9c75025fff4</a></p>\\n<p>The Blueprint ID would be <code>6391086e-85a1-4820-813c-f9c75025fff4</code></p>\\n<p>An example script that leverages this API can be found in the <a href=\"https://github.com/kandji-inc/support/tree/main/api-tools/update-device-record\">Kandji Support GitHub</a></p>\\n<h4 id=\"clearing-the-device-asset-tag\">Clearing the device asset tag</h4>\\n<p>To clear a device asset tag, set the <code>asset_tag</code> value to <code>null</code> in the JSON payload.</p>\\n<pre class=\"click-to-expand-wrapper is-snippet-wrapper\"><code class=\"language-json\">{\\n    \"asset_tag\": null\\n}\\n\\n</code></pre>\\n<h4 id=\"clearing-the-assigned-user-attribute\">Clearing the assigned user attribute</h4>\\n<p>To clear the assigned user for a given device, set the <code>user</code> value to <code>null</code> in the JSON payload.</p>\\n<pre class=\"click-to-expand-wrapper is-snippet-wrapper\"><code class=\"language-json\">{\\n    \"user\": null\\n}\\n\\n</code></pre>\\n<h4 id=\"clearing-all-tags\">Clearing all tags</h4>\\n<p>To clear the assigned tags for a given device, set the <code>tags</code> value to an empty list <code>[]</code> in the JSON payload.</p>\\n<pre class=\"click-to-expand-wrapper is-snippet-wrapper\"><code class=\"language-json\">{\\n    \"tags\": []\\n}\\n\\n</code></pre>\\n
pub async fn api_v1_devices_device_id_patch(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to retrieve the Activation Lock Bypass code.</p>\\n<p>user_based_albc is the user-based Activation Lock bypass code for when Activation Lock is enabled using an personal Apple ID and Find My.</p>\\n<p>device_based_albc is the device-based Activation Lock bypass code for when Activation Lock is enabled by the MDM server.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>\\n
pub async fn api_v1_devices_device_id_secrets_bypasscode_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdSecretsBypasscodeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/secrets/bypasscode", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdSecretsBypasscodeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to retrieve the FileVault Recovery key for a macOS device.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>\\n
pub async fn api_v1_devices_device_id_secrets_filevaultkey_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdSecretsFilevaultkeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/secrets/filevaultkey", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdSecretsFilevaultkeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the Recovery Lock password for a Mac with an Apple Silicon processor and the legacy EFI firmware password for a Mac with an Intel processor.</p>\\n<p>For more details on setting and managing Recovery passwords, see this <a href=\"https://support.kandji.io/support/solutions/articles/72000560472-configure-the-recovery-password-library-item\">Kandji support article</a>.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>\\n
pub async fn api_v1_devices_device_id_secrets_recoverypassword_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdSecretsRecoverypasswordGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/secrets/recoverypassword", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdSecretsRecoverypasswordGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to retrieve the device unlock pin for a macOS device.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>\\n
pub async fn api_v1_devices_device_id_secrets_unlockpin_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdSecretsUnlockpinGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/secrets/unlockpin", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdSecretsUnlockpinGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the full status (parameters and library items) for a specified Device ID.</p>\\n<p>The parameters will be returned as a list of IDs. These IDs can be correlated with the parameter names available here: <a href=\"https://github.com/kandji-inc/support/wiki/Devices-API---Parameter-Correlations\">https://github.com/kandji-inc/support/wiki/Devices-API---Parameter-Correlations</a></p>\\n<h4 id=\"possible-status-values\">Possible status values</h4>\\n<p><strong>Library items</strong></p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th><strong>Value</strong></th>\\n<th><strong>Type</strong></th>\\n<th><strong>Additional Info</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>AVAILABLE</td>\\n<td>string</td>\\n<td>Library item available in Self Service</td>\\n</tr>\\n<tr>\\n<td>ERROR</td>\\n<td>string</td>\\n<td>Audit failure</td>\\n</tr>\\n<tr>\\n<td>EXCLUDED</td>\\n<td>string</td>\\n<td>Not in scope for assignment rule</td>\\n</tr>\\n<tr>\\n<td>INCOMPATIBLE</td>\\n<td>string</td>\\n<td>Not compatible with device or OS version</td>\\n</tr>\\n<tr>\\n<td>PASS</td>\\n<td>string</td>\\n<td>Device meets requirements</td>\\n</tr>\\n<tr>\\n<td>PENDING</td>\\n<td>string</td>\\n<td>Waiting on device, not yet installed (All library items except for config profiles)</td>\\n</tr>\\n<tr>\\n<td>failed</td>\\n<td>string</td>\\n<td>Configuration profile failed to install</td>\\n</tr>\\n<tr>\\n<td>pending</td>\\n<td>string</td>\\n<td>Waiting on device, Configuration profile not yet installed</td>\\n</tr>\\n<tr>\\n<td>success</td>\\n<td>string</td>\\n<td>Configuration profile installed</td>\\n</tr>\\n</tbody>\\n</table>\\n</div><p><strong>Parameters</strong></p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th><strong>Value</strong></th>\\n<th><strong>Type</strong></th>\\n<th><strong>Additional Info</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>ERROR</td>\\n<td>string</td>\\n<td>Audit failure</td>\\n</tr>\\n<tr>\\n<td>INCOMPATIBLE</td>\\n<td>string</td>\\n<td>Not compatible with device or OS version</td>\\n</tr>\\n<tr>\\n<td>PASS</td>\\n<td>string</td>\\n<td>Device meets requirements</td>\\n</tr>\\n<tr>\\n<td>PENDING</td>\\n<td>string</td>\\n<td>Waiting on device. Not yet run.</td>\\n</tr>\\n<tr>\\n<td>REMEDIATED</td>\\n<td>string</td>\\n<td>Parameter remediated</td>\\n</tr>\\n<tr>\\n<td>WARNING</td>\\n<td>string</td>\\n<td>Muted alert</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_devices_device_id_status_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1DevicesDeviceIdStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices/{device_id}/status", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1DevicesDeviceIdStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns a list of devices in a Kandji tenant. Optionally. query parameters can be used to filter results.</p>\\n<p>There is a hard upper limit of 300 results per request. To return addtional results pagination must be used. Pagination examples can be found in the Kandji support <a href=\"https://github.com/kandji-inc/support/tree/main/api-tools/code-examples\">GitHub</a>.</p>\\n
pub async fn api_v1_deviceslimit300_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1Deviceslimit300GetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/devices?limit=300", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1Deviceslimit300GetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <h1 id=\"warning\"><strong>WARNING!</strong></h1>\\n<p>This is a HIGHLY destructive action.</p>\\n<p>Deleting an ADE token will unassign the associated device records from Kandji. For currently enrolled devices that were assigned to Kandji via the delete ADE integration will not be impacted until they are wiped and reprovisioned. This action is essentially the same as removing an ADE token from MDM and then adding it back.</p>\\n<p>If applicable, be sure to reassign the device records in ABM.</p>\\n
pub async fn api_v1_integrations_apple_ade_ade_token_id_delete(configuration: &configuration::Configuration, ade_token_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeAdeTokenIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/{ade_token_id}", local_var_configuration.base_path, ade_token_id=crate::apis::urlencode(ade_token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeAdeTokenIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns a list of devices associated with a specified <code>ade_token_id</code> as well as their enrollment status.</p>\\n<p>When the <code>mdm_device</code> key value is <code>null</code>, this can be taken as an indication that the device is awaiting enrollment into Kandji.</p>\\n<p>When data is present within the mdm_device dictionary, you can reference the <code>device_id</code> as the ID of the enrolled device record.</p>\\n
pub async fn api_v1_integrations_apple_ade_ade_token_id_devices_get(configuration: &configuration::Configuration, ade_token_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeAdeTokenIdDevicesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/{ade_token_id}/devices", local_var_configuration.base_path, ade_token_id=crate::apis::urlencode(ade_token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeAdeTokenIdDevicesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns a specific ADE integration based on the <code>ade_token_id</code> passed.</p>\\n
pub async fn api_v1_integrations_apple_ade_ade_token_id_get(configuration: &configuration::Configuration, ade_token_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeAdeTokenIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/{ade_token_id}", local_var_configuration.base_path, ade_token_id=crate::apis::urlencode(ade_token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeAdeTokenIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request will update the default blueprint, phone number, and email address in an existing ADE integration.</p>\\n<p>The default <code>blueprint_id</code>, <code>phone</code> number, and <code>email</code> address must be sent in the request.</p>\\n
pub async fn api_v1_integrations_apple_ade_ade_token_id_patch(configuration: &configuration::Configuration, ade_token_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeAdeTokenIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/{ade_token_id}", local_var_configuration.base_path, ade_token_id=crate::apis::urlencode(ade_token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeAdeTokenIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request will renew an existing ADE integration.</p>\\n<p>The default <code>blueprint_id</code>, <code>phone</code> number, <code>email</code> address, and MDM server token <code>file</code> from the associated MDM server in ABM are required and must be sent in the request.</p>\\n
pub async fn api_v1_integrations_apple_ade_ade_token_id_renew_post(configuration: &configuration::Configuration, ade_token_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeAdeTokenIdRenewPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/{ade_token_id}/renew", local_var_configuration.base_path, ade_token_id=crate::apis::urlencode(ade_token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeAdeTokenIdRenewPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get information about a specific Automated Device Enrollment device.</p>\\n
pub async fn api_v1_integrations_apple_ade_devices_device_id_get(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeDevicesDeviceIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/devices/{device_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeDevicesDeviceIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Update a specific Automated Device Enrollment device's blueprint assignment, user assignment, and asset tag.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>device_id</code> (path parameter): The unique identifier of the device.</p>\\n
pub async fn api_v1_integrations_apple_ade_devices_device_id_patch(configuration: &configuration::Configuration, device_id: &str) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeDevicesDeviceIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/devices/{device_id}", local_var_configuration.base_path, device_id=crate::apis::urlencode(device_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeDevicesDeviceIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get a list of Automated Device Enrollment devices.</p>\\n
pub async fn api_v1_integrations_apple_ade_devices_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeDevicesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/devices", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeDevicesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns a list of configured ADE integrations.</p>\\n
pub async fn api_v1_integrations_apple_ade_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request will create a new ADE integration.</p>\\n<p>The default <code>blueprint_id</code>, <code>phone</code> number, <code>email</code> address, and MDM server token <code>file</code> downloaded from ABM are required and must be sent in the request.</p>\\n
pub async fn api_v1_integrations_apple_ade_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request returns the public key used to create an MDM server connection in Apple Business Manager.</p>\\n<p>The encoded information needs to be saved to a file with the <code>.pem</code> format and then uploaded to ABM.</p>\\n
pub async fn api_v1_integrations_apple_ade_public_key_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1IntegrationsAppleAdePublicKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/integrations/apple/ade/public_key/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1IntegrationsAppleAdePublicKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint makes a request to retrieve a list of custom apps from the Kandji library.</p>\\n
pub async fn api_v1_library_custom_apps_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomAppsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-apps", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomAppsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>NOTICE: This is permanent so be careful.</p>\\n<p>This endpoint sends a request to delete a specific custom app from the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_apps_library_item_id_delete(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomAppsLibraryItemIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-apps/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomAppsLibraryItemIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint retrieves details about a specific custom app from the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_apps_library_item_id_get(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomAppsLibraryItemIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-apps/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomAppsLibraryItemIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to update a custom app in the Kandji library.</p>\\n<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_apps_library_item_id_patch(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomAppsLibraryItemIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-apps/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomAppsLibraryItemIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to create a custom app in the Kandji library.</p>\\n<p>Must have already generated a <code>file_key</code> via <code>Create custom app</code> endpoint and uploaded the file to S3 using a request similar to the <code>Upload to S3</code> example.</p>\\n
pub async fn api_v1_library_custom_apps_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomAppsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-apps", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomAppsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request retrieves the S3 upload details need for uploading the app to Amazon S3.</p>\\n<p>Creates a pre-signed <code>post_url</code> to upload a new Custom App to S3.</p>\\n<p>The provided <code>name</code> will be used to calculate a unique <code>file_key</code> in S3.</p>\\n<p>A separate request will have to be made to the <code>Upload to S3</code> endpoint to upload the file to S3 directly using the <code>post_url</code> and <code>post_data</code> from the <code>Upload Custom App</code> response.</p>\\n
pub async fn api_v1_library_custom_apps_upload_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomAppsUploadPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-apps/upload", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomAppsUploadPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint makes a request to retrieve a list of custom profiles from the Kandji library.</p>\\n
pub async fn api_v1_library_custom_profiles_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-profiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>NOTICE: This is permanent so be careful.</p>\\n<p>This endpoint sends a request to delete a specific custom profile from the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_profiles_library_item_id_delete(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomProfilesLibraryItemIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-profiles/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomProfilesLibraryItemIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint retrieves details about a specific custom app from the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_profiles_library_item_id_get(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomProfilesLibraryItemIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-profiles/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomProfilesLibraryItemIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to update a custom profile in the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_profiles_library_item_id_patch(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomProfilesLibraryItemIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-profiles/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomProfilesLibraryItemIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to create a custom profile in the Kandji library.</p>\\n
pub async fn api_v1_library_custom_profiles_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomProfilesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-profiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomProfilesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint makes a request to retrieve a list of custom scripts from the Kandji library.</p>\\n
pub async fn api_v1_library_custom_scripts_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomScriptsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-scripts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomScriptsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>NOTICE: This is permanent so be careful.</p>\\n<p>This endpoint sends a request to delete a specific custom scripts from the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_scripts_library_item_id_delete(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomScriptsLibraryItemIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-scripts/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomScriptsLibraryItemIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint retrieves details about a specific custom script from the Kandji library.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_custom_scripts_library_item_id_get(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomScriptsLibraryItemIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-scripts/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomScriptsLibraryItemIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to update a custom script in the Kandji library.</p>\\n
pub async fn api_v1_library_custom_scripts_library_item_id_patch(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryCustomScriptsLibraryItemIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-scripts/{library_item_id}", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomScriptsLibraryItemIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This request allows you to create a custom script in the Kandji library.</p>\\n
pub async fn api_v1_library_custom_scripts_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1LibraryCustomScriptsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/custom-scripts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryCustomScriptsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint retrieves the activity related to a specific library item. Activity is listed from newest to oldest.</p>\\n<p>To see a delta of the activity events between now and the last request, you can store the newest entry from the previous request and then look for that entry in the next request. Any entry post that will be the delta.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_library_items_library_item_id_activity_get(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryLibraryItemsLibraryItemIdActivityGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/library-items/{library_item_id}/activity", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryLibraryItemsLibraryItemIdActivityGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint retrieves the statuses related to a specific library item.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>library_item_id</code> (path parameter): The unique identifier of the library item.</p>\\n
pub async fn api_v1_library_library_items_library_item_id_status_get(configuration: &configuration::Configuration, library_item_id: &str) -> Result<serde_json::Value, Error<ApiV1LibraryLibraryItemsLibraryItemIdStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/library/library-items/{library_item_id}/status", local_var_configuration.base_path, library_item_id=crate::apis::urlencode(library_item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1LibraryLibraryItemsLibraryItemIdStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get activation lock attributes for devices.</p>\\n
pub async fn api_v1_prism_activation_lock_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismActivationLockGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/activation_lock", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismActivationLockGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Application Firewall details for macOS.</p>\\n
pub async fn api_v1_prism_application_firewall_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismApplicationFirewallGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/application_firewall", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismApplicationFirewallGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get the applications installed on macOS, iOS, iPadOS, and tvOS devices.</p>\\n
pub async fn api_v1_prism_apps_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismAppsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/apps", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismAppsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get certificate details.</p>\\n
pub async fn api_v1_prism_certificates_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismCertificatesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/certificates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismCertificatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get the total record count for the specified Prism category.</p>\\n<p>If a category contains spaces substitute the spaces for underscores (\"_\") when using the API query.</p>\\n<p>Example: <code>Device information</code> becomes <code>device_information</code>.</p>\\n
pub async fn api_v1_prism_countcategoryapps_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismCountcategoryappsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/count?category=apps", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismCountcategoryappsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Desktop and Screensaver details for macOS.</p>\\n
pub async fn api_v1_prism_desktop_and_screensaver_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismDesktopAndScreensaverGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/desktop_and_screensaver", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismDesktopAndScreensaverGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get attributes about devices.</p>\\n
pub async fn api_v1_prism_device_information_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismDeviceInformationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/device_information", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismDeviceInformationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get an export request's status. To download the export, use the <code>signed_url</code>. This will download a CSV file containing the exported category information.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p>export_id (path parameter): The unique identifier of the the export job.</p>\\n
pub async fn api_v1_prism_export_export_id_get(configuration: &configuration::Configuration, export_id: &str) -> Result<serde_json::Value, Error<ApiV1PrismExportExportIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/export/{export_id}", local_var_configuration.base_path, export_id=crate::apis::urlencode(export_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismExportExportIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Request export of a category. The <code>id</code> key is used when checking the export status using the <em>Request category export</em> endpoint.</p>\\n<p><strong>Request Body Parameters: application/json</strong></p>\\n<div class=\"click-to-expand-wrapper is-table-wrapper\"><table>\\n<thead>\\n<tr>\\n<th>Key</th>\\n<th>Type</th>\\n<th>Possible value(s)</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>blueprint_ids</code></td>\\n<td><code>array</code></td>\\n<td><code>[\"string\", \"string\", \"string\"]</code></td>\\n<td>List of one or more comma separate blueprint IDs.</td>\\n</tr>\\n<tr>\\n<td><code>category</code></td>\\n<td><code>string</code></td>\\n<td><code>apps</code> ,  <br /><code>activation_lock</code> ,  <br /><code>desktop_and_screensaver</code> ,  <br /><code>device_information</code> ,  <br /><code>gatekeeper_and_xprotect</code> ,  <br /><code>installed_profiles</code> ,  <br /><code>kernel_extensions</code> ,  <br /><code>local_users</code> ,  <br /><code>launch_agents_and_daemons</code> ,  <br /><code>system_extensions</code> ,  <br /><code>startup_settings</code> ,  <br /><code>transparency_database</code></td>\\n<td>Only one category per export reqest.</td>\\n</tr>\\n<tr>\\n<td><code>device_families</code></td>\\n<td><code>array</code></td>\\n<td><code>[\"Mac\", \"iPhone\", \"iPad\", \"tvOS\"]</code></td>\\n<td>List of one or more comma separted string values for device families.</td>\\n</tr>\\n<tr>\\n<td><code>filter</code></td>\\n<td><code>object</code></td>\\n<td><code>{\"apple_silicon\": {\"eq\": true}, \"device__name\": {\"like\": [\"this\", \"or_this\"]}}</code></td>\\n<td>JSON schema object containing one or more key value pairs.  <br />  <br /><strong>Note</strong>: For detailed information on fiters, see the Filters section at the begining of the Visibility API endpoints in this doc.</td>\\n</tr>\\n<tr>\\n<td><code>sort_by</code></td>\\n<td><code>string</code></td>\\n<td></td>\\n<td>Sort results by the name of a given response body key in either ascending (default behavior) or descending(`-`) order.</td>\\n</tr>\\n</tbody>\\n</table>\\n</div>
pub async fn api_v1_prism_export_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismExportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/export", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismExportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get FileVault information for macOS.</p>\\n
pub async fn api_v1_prism_filevault_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismFilevaultGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/filevault", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismFilevaultGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Gatekeeper and XProtect attributes for macOS.</p>\\n
pub async fn api_v1_prism_gatekeeper_and_xprotect_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismGatekeeperAndXprotectGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/gatekeeper_and_xprotect", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismGatekeeperAndXprotectGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Installed Profiles attributes for macOS, iOS, iPadOS, and tvOS.</p>\\n
pub async fn api_v1_prism_installed_profiles_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismInstalledProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/installed_profiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismInstalledProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Kernel Extension attributes for macOS.</p>\\n
pub async fn api_v1_prism_kernel_extensions_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismKernelExtensionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/kernel_extensions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismKernelExtensionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Launch Agents and Daemons installed on macOS.</p>\\n
pub async fn api_v1_prism_launch_agents_and_daemons_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismLaunchAgentsAndDaemonsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/launch_agents_and_daemons", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismLaunchAgentsAndDaemonsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Local Users detials for macOS.</p>\\n
pub async fn api_v1_prism_local_users_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismLocalUsersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/local_users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismLocalUsersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Startup settings for macOS.</p>\\n
pub async fn api_v1_prism_startup_settings_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismStartupSettingsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/startup_settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismStartupSettingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get System Extension attributes for macOS.</p>\\n
pub async fn api_v1_prism_system_extensions_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismSystemExtensionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/system_extensions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismSystemExtensionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get Transparency Database (TCC) attributes for macOS.</p>\\n
pub async fn api_v1_prism_transparency_database_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1PrismTransparencyDatabaseGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/prism/transparency_database", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1PrismTransparencyDatabaseGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint retrieves a list of self-service categories and their associated IDs.</p>\\n<p>If you are planning to make a Library item available in Self Service under a specific category, you can call this endpoint to get the category ID and then use that ID when creating or updating the library item via the Kandji API.</p>\\n
pub async fn api_v1_self_service_categories_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1SelfServiceCategoriesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/self-service/categories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1SelfServiceCategoriesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Returns Kandji tenant licensing and utilization information.</p>\\n
pub async fn api_v1_settings_licensing_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1SettingsLicensingGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/settings/licensing", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1SettingsLicensingGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Create a tag. Can only create one tag per request.</p>\\n
pub async fn api_v1_tags_post(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1TagsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/tags", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1TagsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Delete a tag.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>tag_id</code> (path parameter): The unique identifier of the tag.</p>\\n
pub async fn api_v1_tags_tag_id_delete(configuration: &configuration::Configuration, tag_id: &str) -> Result<serde_json::Value, Error<ApiV1TagsTagIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/tags/{tag_id}", local_var_configuration.base_path, tag_id=crate::apis::urlencode(tag_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1TagsTagIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Update tag name.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>tag_id</code> (path parameter): The unique identifier of the tag.</p>\\n
pub async fn api_v1_tags_tag_id_patch(configuration: &configuration::Configuration, tag_id: &str) -> Result<serde_json::Value, Error<ApiV1TagsTagIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/tags/{tag_id}", local_var_configuration.base_path, tag_id=crate::apis::urlencode(tag_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1TagsTagIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Return configured tags.</p>\\n
pub async fn api_v1_tagssearchaccuhive_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1TagssearchaccuhiveGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/tags?search=accuhive", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1TagssearchaccuhiveGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Get threat details.</p>\\n
pub async fn api_v1_threat_details_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1ThreatDetailsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/threat-details", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1ThreatDetailsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint makes a request to retrieve a list of users from user directory integrations.</p>\\n<p>A maximum of 300 records are returned per request, and pagination can be performed leveraging the URLs provided in the <code>next</code> and <code>previous</code> keys in the response. If there are no more results available, the respective key will be <code>null</code>.</p>\\n
pub async fn api_v1_users_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ApiV1UsersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1UsersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>This endpoint makes a request to retrieve a specified user directory integration user by id.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p>user_id (path parameter): The unique identifier of the user directory integration user.</p>\\n
pub async fn api_v1_users_user_id_get(configuration: &configuration::Configuration, user_id: &str) -> Result<serde_json::Value, Error<ApiV1UsersUserIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/users/{user_id}", local_var_configuration.base_path, user_id=crate::apis::urlencode(user_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApiV1UsersUserIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// <p>Example showing separate post request to upload the file to Amazon S3.</p>\\n<h3 id=\"request-parameters\">Request Parameters</h3>\\n<p><code>post_url</code> (path parameter): The <code>post_url</code> value from the <code>Upload custom app</code> response.</p>\\n<h3 id=\"request-body\">Request Body</h3>\\n<p>For the request body, use the contents of the <code>post_data</code> object in the <code>Upload Custom App</code> endpoint response (example response below) and supply the path to the custom app file in the <code>file</code> request parameter.</p>\\n<h4 id=\"example-post_data-object\">Example post_data object</h4>\\n<pre class=\"click-to-expand-wrapper is-snippet-wrapper\"><code class=\"language-json\">\"post_data\": {\\n   \"key\": \"(field to post along with file to S3 -- the key for the uploaded file)\",\\n   \"x-amz-algorithm\": \"(field to post along with file to S3)\",\\n   \"x-amz-credential\": \"(field to post along with file to S3)\",\\n   \"x-amz-date\": \"(field to post along with file to S3)\",\\n   \"x-amz-security-token\": \"(field to post along with file to S3)\",\\n   \"policy\": \"(field to post along with file to S3)\",\\n   \"x-amz-signature\": \"(field to post along with file to S3)\",\\n}\\n\\n</code></pre>\\n
pub async fn post_url_post(configuration: &configuration::Configuration, post_url: &str) -> Result<serde_json::Value, Error<PostUrlPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/{post_url}", local_var_configuration.base_path, post_url=crate::apis::urlencode(post_url));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostUrlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

